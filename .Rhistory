weather.df <- weather.results$hourly$data
# convert UNIX time to Dates
weather.df$time <- anytime(weather.df$time, tz = location.timezone)
# separate date and time
weather.df$time.only <- format(as.POSIXct(weather.df$time) , format = "%H:%M:%S")
weather.df <- weather.df %>% mutate(time, date.only = as.Date(time))
# return weather.df
return(weather.df)
}
# test
data <- weatherData("Olympia", "WA", "2017-05-25")
library(jsonlite)
library(rgeos)
library(rgdal)
library(httr)
library(dplyr)
library(anytime)
# Latitude & Longitude Retrieval for API Calls
# --------------------------------------------
# Code for findLatLong and findGeoData sourced from:
# https://stackoverflow.com/posts/27868207/revisions
# Returns a data frame that contains the longitude and latitude
# for the given state and city.
# Input format: findLatLong(geog_db, "Portland", "ME")
# Ex: lon       lat       city      state
#     -70.25404 43.66186  Portland   ME
findLatLong <- function(geo_db, city, state) {
do.call(rbind.data.frame, mapply(function(x, y) {
geo_db %>% filter(city==x, state==y)
}, city, state, SIMPLIFY=FALSE))
}
# Global Variables
# Options list for states and capital cities
cities <- c("Montgomery, AL", "Juneau, AK", "Phoenix, AZ",
"Little Rock, AR", "Sacramento, CA", "Denver, CO",
"Hartford, CT", "Dover, DE", "Tallahassee, FL",
"Atlanta, GA", "Honolulu, HI", "Boise, ID", "Springfield, IL",
"Indianapolis, IN", "Des Moines, IA", "Topeka, KS", "Frankfort, KY",
"Baton Rouge, LA", "Augusta, ME", "Annapolis, MD", "Boston, MA",
"Lansing, MI", "St. Paul, MN", "Jackson, MS", "Jefferson City, MO",
"Helena, MT", "Lincoln, NE", "Carson City, NV", "Concord, NH",
"Trenton, NJ", "Santa Fe, NM", "Albany, NY", "Raleigh, NC",
"Bismarck, ND", "Columbus, OH", "Oklahoma City, OK", "Salem, OR",
"Harrisburg, PA", "Providence, RI", "Columbia, SC",
"Pierre, SD", "Nashville, TN", "Austin, TX", "Salt Lake City, UT",
"Montpelier, VT", "Richmond, VA", "Olympia, WA", "Charleston, WV",
"Madison, WI", "Cheyenne, WY"
)
# Plot list
plots <- c("Temperature", "Wind speed", "Cloud coverage")
# Retrieves dataset for towns and cities in Canada/US with latitudinal and longitudinal data for API calls
geo_data <- read.csv("scripts/geo_data.csv")
city <- "Portland"
state <- "ME"
day <- "28 May 2017"
# Retrieves a data frame with weather data for the specified day with the given city and state,
# with hourly time block starting from midnight of the day requested,
# continuing until midnight of the following day. Hourly time blocks start from the current system time.
# input format: weatherData("Portland", "ME", "28 May 2017"), multiple Date formats should work
# Ex: temperature     time
#     45.3690         2017-05-27 14:00:00
weatherData <- function(city, state, day) {
# Retrieve latitude and longitude for given city and state
lat.long.df <- geo_data %>% findLatLong(city, state)
longitude <- lat.long.df[,1]
latitude <- lat.long.df[,2]
# Convert given Date to UNIX format
unix.time.day <- as.numeric(as.POSIXct(anydate(day)))
# Retrieve API key from key.JSON (stored in JSON for security)
key <- fromJSON(txt = "access-keys.json")$weather$key
# Convert given Date to UNIX format
unix.time.day <- as.numeric(as.POSIXct(anydate(day)))
# setting params for API  call
base.url <- "https://api.darksky.net/forecast/"
weather.uri <- paste0(base.url, key, "/", latitude, ",", longitude, ",", unix.time.day)
weather.params <- list(exclude = paste0("currently", ",", "minutely", ",", "daily", ",", "flags"))
# retrieving data from API
weather.response <- GET(weather.uri, query = weather.params)
weather.body <- content(weather.response, "text")
weather.results <- fromJSON(weather.body)
# retrieve location time zone to appropriately convert UNIX time
location.timezone <- weather.results$timezone
# Gets data sorted by hour
weather.df <- weather.results$hourly$data
# convert UNIX time to Dates
weather.df$time <- anytime(weather.df$time, tz = location.timezone)
# separate date and time
weather.df$time.only <- format(as.POSIXct(weather.df$time) , format = "%H:%M:%S")
weather.df <- weather.df %>% mutate(time, date.only = as.Date(time))
# return weather.df
return(weather.df)
}
# test
data <- weatherData("Olympia", "WA", "2017-05-25")
library(jsonlite)
library(rgeos)
library(rgdal)
library(httr)
library(dplyr)
library(anytime)
# Latitude & Longitude Retrieval for API Calls
# --------------------------------------------
# Code for findLatLong and findGeoData sourced from:
# https://stackoverflow.com/posts/27868207/revisions
# Returns a data frame that contains the longitude and latitude
# for the given state and city.
# Input format: findLatLong(geog_db, "Portland", "ME")
# Ex: lon       lat       city      state
#     -70.25404 43.66186  Portland   ME
findLatLong <- function(geo_db, city, state) {
do.call(rbind.data.frame, mapply(function(x, y) {
geo_db %>% filter(city==x, state==y)
}, city, state, SIMPLIFY=FALSE))
}
# Global Variables
# Options list for states and capital cities
cities <- c("Montgomery, AL", "Juneau, AK", "Phoenix, AZ",
"Little Rock, AR", "Sacramento, CA", "Denver, CO",
"Hartford, CT", "Dover, DE", "Tallahassee, FL",
"Atlanta, GA", "Honolulu, HI", "Boise, ID", "Springfield, IL",
"Indianapolis, IN", "Des Moines, IA", "Topeka, KS", "Frankfort, KY",
"Baton Rouge, LA", "Augusta, ME", "Annapolis, MD", "Boston, MA",
"Lansing, MI", "St. Paul, MN", "Jackson, MS", "Jefferson City, MO",
"Helena, MT", "Lincoln, NE", "Carson City, NV", "Concord, NH",
"Trenton, NJ", "Santa Fe, NM", "Albany, NY", "Raleigh, NC",
"Bismarck, ND", "Columbus, OH", "Oklahoma City, OK", "Salem, OR",
"Harrisburg, PA", "Providence, RI", "Columbia, SC",
"Pierre, SD", "Nashville, TN", "Austin, TX", "Salt Lake City, UT",
"Montpelier, VT", "Richmond, VA", "Olympia, WA", "Charleston, WV",
"Madison, WI", "Cheyenne, WY"
)
# Plot list
plots <- c("Temperature", "Wind speed", "Cloud coverage")
# Retrieves dataset for towns and cities in Canada/US with latitudinal and longitudinal data for API calls
geo_data <- read.csv("scripts/geo_data.csv")
city <- "Portland"
state <- "ME"
day <- "28 May 2017"
# Retrieves a data frame with weather data for the specified day with the given city and state,
# with hourly time block starting from midnight of the day requested,
# continuing until midnight of the following day. Hourly time blocks start from the current system time.
# input format: weatherData("Portland", "ME", "28 May 2017"), multiple Date formats should work
# Ex: temperature     time
#     45.3690         2017-05-27 14:00:00
weatherData <- function(city, state, day) {
# Retrieve latitude and longitude for given city and state
lat.long.df <- geo_data %>% findLatLong(city, state)
longitude <- lat.long.df[,1]
latitude <- lat.long.df[,2]
# Convert given Date to UNIX format
unix.time.day <- as.numeric(as.POSIXct(anydate(day)))
# Retrieve API key from key.JSON (stored in JSON for security)
key <- fromJSON("access-keys.json", simplifyVector = FALSE)$weather$key
# Convert given Date to UNIX format
unix.time.day <- as.numeric(as.POSIXct(anydate(day)))
# setting params for API  call
base.url <- "https://api.darksky.net/forecast/"
weather.uri <- paste0(base.url, key, "/", latitude, ",", longitude, ",", unix.time.day)
weather.params <- list(exclude = paste0("currently", ",", "minutely", ",", "daily", ",", "flags"))
# retrieving data from API
weather.response <- GET(weather.uri, query = weather.params)
weather.body <- content(weather.response, "text")
weather.results <- fromJSON(weather.body)
# retrieve location time zone to appropriately convert UNIX time
location.timezone <- weather.results$timezone
# Gets data sorted by hour
weather.df <- weather.results$hourly$data
# convert UNIX time to Dates
weather.df$time <- anytime(weather.df$time, tz = location.timezone)
# separate date and time
weather.df$time.only <- format(as.POSIXct(weather.df$time) , format = "%H:%M:%S")
weather.df <- weather.df %>% mutate(time, date.only = as.Date(time))
# return weather.df
return(weather.df)
}
# test
data <- weatherData("Olympia", "WA", "2017-05-25")
library(jsonlite)
library(rgeos)
library(rgdal)
library(httr)
library(dplyr)
library(anytime)
# Latitude & Longitude Retrieval for API Calls
# --------------------------------------------
# Code for findLatLong and findGeoData sourced from:
# https://stackoverflow.com/posts/27868207/revisions
# Returns a data frame that contains the longitude and latitude
# for the given state and city.
# Input format: findLatLong(geog_db, "Portland", "ME")
# Ex: lon       lat       city      state
#     -70.25404 43.66186  Portland   ME
findLatLong <- function(geo_db, city, state) {
do.call(rbind.data.frame, mapply(function(x, y) {
geo_db %>% filter(city==x, state==y)
}, city, state, SIMPLIFY=FALSE))
}
# Global Variables
# Options list for states and capital cities
cities <- c("Montgomery, AL", "Juneau, AK", "Phoenix, AZ",
"Little Rock, AR", "Sacramento, CA", "Denver, CO",
"Hartford, CT", "Dover, DE", "Tallahassee, FL",
"Atlanta, GA", "Honolulu, HI", "Boise, ID", "Springfield, IL",
"Indianapolis, IN", "Des Moines, IA", "Topeka, KS", "Frankfort, KY",
"Baton Rouge, LA", "Augusta, ME", "Annapolis, MD", "Boston, MA",
"Lansing, MI", "St. Paul, MN", "Jackson, MS", "Jefferson City, MO",
"Helena, MT", "Lincoln, NE", "Carson City, NV", "Concord, NH",
"Trenton, NJ", "Santa Fe, NM", "Albany, NY", "Raleigh, NC",
"Bismarck, ND", "Columbus, OH", "Oklahoma City, OK", "Salem, OR",
"Harrisburg, PA", "Providence, RI", "Columbia, SC",
"Pierre, SD", "Nashville, TN", "Austin, TX", "Salt Lake City, UT",
"Montpelier, VT", "Richmond, VA", "Olympia, WA", "Charleston, WV",
"Madison, WI", "Cheyenne, WY"
)
# Plot list
plots <- c("Temperature", "Wind speed", "Cloud coverage")
# Retrieves dataset for towns and cities in Canada/US with latitudinal and longitudinal data for API calls
geo_data <- read.csv("scripts/geo_data.csv")
city <- "Portland"
state <- "ME"
day <- "28 May 2017"
# Retrieves a data frame with weather data for the specified day with the given city and state,
# with hourly time block starting from midnight of the day requested,
# continuing until midnight of the following day. Hourly time blocks start from the current system time.
# input format: weatherData("Portland", "ME", "28 May 2017"), multiple Date formats should work
# Ex: temperature     time
#     45.3690         2017-05-27 14:00:00
weatherData <- function(city, state, day) {
# Retrieve latitude and longitude for given city and state
lat.long.df <- geo_data %>% findLatLong(city, state)
longitude <- lat.long.df[,1]
latitude <- lat.long.df[,2]
# Convert given Date to UNIX format
unix.time.day <- as.numeric(as.POSIXct(anydate(day)))
# Retrieve API key from key.JSON (stored in JSON for security)
key <- fromJSON("access-keys.json")$weather$key
# Convert given Date to UNIX format
unix.time.day <- as.numeric(as.POSIXct(anydate(day)))
# setting params for API  call
base.url <- "https://api.darksky.net/forecast/"
weather.uri <- paste0(base.url, key, "/", latitude, ",", longitude, ",", unix.time.day)
weather.params <- list(exclude = paste0("currently", ",", "minutely", ",", "daily", ",", "flags"))
# retrieving data from API
weather.response <- GET(weather.uri, query = weather.params)
weather.body <- content(weather.response, "text")
weather.results <- fromJSON(weather.body)
# retrieve location time zone to appropriately convert UNIX time
location.timezone <- weather.results$timezone
# Gets data sorted by hour
weather.df <- weather.results$hourly$data
# convert UNIX time to Dates
weather.df$time <- anytime(weather.df$time, tz = location.timezone)
# separate date and time
weather.df$time.only <- format(as.POSIXct(weather.df$time) , format = "%H:%M:%S")
weather.df <- weather.df %>% mutate(time, date.only = as.Date(time))
# return weather.df
return(weather.df)
}
# test
data <- weatherData("Olympia", "WA", "2017-05-25")
library(jsonlite)
library(rgeos)
library(rgdal)
library(httr)
library(dplyr)
library(anytime)
# Latitude & Longitude Retrieval for API Calls
# --------------------------------------------
# Code for findLatLong and findGeoData sourced from:
# https://stackoverflow.com/posts/27868207/revisions
# Returns a data frame that contains the longitude and latitude
# for the given state and city.
# Input format: findLatLong(geog_db, "Portland", "ME")
# Ex: lon       lat       city      state
#     -70.25404 43.66186  Portland   ME
findLatLong <- function(geo_db, city, state) {
do.call(rbind.data.frame, mapply(function(x, y) {
geo_db %>% filter(city==x, state==y)
}, city, state, SIMPLIFY=FALSE))
}
# Global Variables
# Options list for states and capital cities
cities <- c("Montgomery, AL", "Juneau, AK", "Phoenix, AZ",
"Little Rock, AR", "Sacramento, CA", "Denver, CO",
"Hartford, CT", "Dover, DE", "Tallahassee, FL",
"Atlanta, GA", "Honolulu, HI", "Boise, ID", "Springfield, IL",
"Indianapolis, IN", "Des Moines, IA", "Topeka, KS", "Frankfort, KY",
"Baton Rouge, LA", "Augusta, ME", "Annapolis, MD", "Boston, MA",
"Lansing, MI", "St. Paul, MN", "Jackson, MS", "Jefferson City, MO",
"Helena, MT", "Lincoln, NE", "Carson City, NV", "Concord, NH",
"Trenton, NJ", "Santa Fe, NM", "Albany, NY", "Raleigh, NC",
"Bismarck, ND", "Columbus, OH", "Oklahoma City, OK", "Salem, OR",
"Harrisburg, PA", "Providence, RI", "Columbia, SC",
"Pierre, SD", "Nashville, TN", "Austin, TX", "Salt Lake City, UT",
"Montpelier, VT", "Richmond, VA", "Olympia, WA", "Charleston, WV",
"Madison, WI", "Cheyenne, WY"
)
# Plot list
plots <- c("Temperature", "Wind speed", "Cloud coverage")
# Retrieves dataset for towns and cities in Canada/US with latitudinal and longitudinal data for API calls
geo_data <- read.csv("scripts/geo_data.csv")
city <- "Portland"
state <- "ME"
day <- "28 May 2017"
# Retrieves a data frame with weather data for the specified day with the given city and state,
# with hourly time block starting from midnight of the day requested,
# continuing until midnight of the following day. Hourly time blocks start from the current system time.
# input format: weatherData("Portland", "ME", "28 May 2017"), multiple Date formats should work
# Ex: temperature     time
#     45.3690         2017-05-27 14:00:00
weatherData <- function(city, state, day) {
# Retrieve latitude and longitude for given city and state
lat.long.df <- geo_data %>% findLatLong(city, state)
longitude <- lat.long.df[,1]
latitude <- lat.long.df[,2]
# Convert given Date to UNIX format
unix.time.day <- as.numeric(as.POSIXct(anydate(day)))
# Retrieve API key from key.JSON (stored in JSON for security)
name.file <- "access-keys.json"
key <- fromJSON(name.file)$weather$key
# Convert given Date to UNIX format
unix.time.day <- as.numeric(as.POSIXct(anydate(day)))
# setting params for API  call
base.url <- "https://api.darksky.net/forecast/"
weather.uri <- paste0(base.url, key, "/", latitude, ",", longitude, ",", unix.time.day)
weather.params <- list(exclude = paste0("currently", ",", "minutely", ",", "daily", ",", "flags"))
# retrieving data from API
weather.response <- GET(weather.uri, query = weather.params)
weather.body <- content(weather.response, "text")
weather.results <- fromJSON(weather.body)
# retrieve location time zone to appropriately convert UNIX time
location.timezone <- weather.results$timezone
# Gets data sorted by hour
weather.df <- weather.results$hourly$data
# convert UNIX time to Dates
weather.df$time <- anytime(weather.df$time, tz = location.timezone)
# separate date and time
weather.df$time.only <- format(as.POSIXct(weather.df$time) , format = "%H:%M:%S")
weather.df <- weather.df %>% mutate(time, date.only = as.Date(time))
# return weather.df
return(weather.df)
}
# test
data <- weatherData("Olympia", "WA", "2017-05-25")
library(jsonlite)
library(rgeos)
library(rgdal)
library(httr)
library(dplyr)
library(anytime)
# Latitude & Longitude Retrieval for API Calls
# --------------------------------------------
# Code for findLatLong and findGeoData sourced from:
# https://stackoverflow.com/posts/27868207/revisions
# Returns a data frame that contains the longitude and latitude
# for the given state and city.
# Input format: findLatLong(geog_db, "Portland", "ME")
# Ex: lon       lat       city      state
#     -70.25404 43.66186  Portland   ME
findLatLong <- function(geo_db, city, state) {
do.call(rbind.data.frame, mapply(function(x, y) {
geo_db %>% filter(city==x, state==y)
}, city, state, SIMPLIFY=FALSE))
}
# Global Variables
# Options list for states and capital cities
cities <- c("Montgomery, AL", "Juneau, AK", "Phoenix, AZ",
"Little Rock, AR", "Sacramento, CA", "Denver, CO",
"Hartford, CT", "Dover, DE", "Tallahassee, FL",
"Atlanta, GA", "Honolulu, HI", "Boise, ID", "Springfield, IL",
"Indianapolis, IN", "Des Moines, IA", "Topeka, KS", "Frankfort, KY",
"Baton Rouge, LA", "Augusta, ME", "Annapolis, MD", "Boston, MA",
"Lansing, MI", "St. Paul, MN", "Jackson, MS", "Jefferson City, MO",
"Helena, MT", "Lincoln, NE", "Carson City, NV", "Concord, NH",
"Trenton, NJ", "Santa Fe, NM", "Albany, NY", "Raleigh, NC",
"Bismarck, ND", "Columbus, OH", "Oklahoma City, OK", "Salem, OR",
"Harrisburg, PA", "Providence, RI", "Columbia, SC",
"Pierre, SD", "Nashville, TN", "Austin, TX", "Salt Lake City, UT",
"Montpelier, VT", "Richmond, VA", "Olympia, WA", "Charleston, WV",
"Madison, WI", "Cheyenne, WY"
)
# Plot list
plots <- c("Temperature", "Wind speed", "Cloud coverage")
# Retrieves dataset for towns and cities in Canada/US with latitudinal and longitudinal data for API calls
geo_data <- read.csv("scripts/geo_data.csv")
city <- "Portland"
state <- "ME"
day <- "28 May 2017"
# Retrieves a data frame with weather data for the specified day with the given city and state,
# with hourly time block starting from midnight of the day requested,
# continuing until midnight of the following day. Hourly time blocks start from the current system time.
# input format: weatherData("Portland", "ME", "28 May 2017"), multiple Date formats should work
# Ex: temperature     time
#     45.3690         2017-05-27 14:00:00
weatherData <- function(city, state, day) {
# Retrieve latitude and longitude for given city and state
lat.long.df <- geo_data %>% findLatLong(city, state)
longitude <- lat.long.df[,1]
latitude <- lat.long.df[,2]
# Convert given Date to UNIX format
unix.time.day <- as.numeric(as.POSIXct(anydate(day)))
# Retrieve API key from key.JSON (stored in JSON for security)
key <- fromJSON(txt = "access-keys.json")$weather$key
# Convert given Date to UNIX format
unix.time.day <- as.numeric(as.POSIXct(anydate(day)))
# setting params for API  call
base.url <- "https://api.darksky.net/forecast/"
weather.uri <- paste0(base.url, key, "/", latitude, ",", longitude, ",", unix.time.day)
weather.params <- list(exclude = paste0("currently", ",", "minutely", ",", "daily", ",", "flags"))
# retrieving data from API
weather.response <- GET(weather.uri, query = weather.params)
weather.body <- content(weather.response, "text")
weather.results <- fromJSON(weather.body)
# retrieve location time zone to appropriately convert UNIX time
location.timezone <- weather.results$timezone
# Gets data sorted by hour
weather.df <- weather.results$hourly$data
# convert UNIX time to Dates
weather.df$time <- anytime(weather.df$time, tz = location.timezone)
# separate date and time
weather.df$time.only <- format(as.POSIXct(weather.df$time) , format = "%H:%M:%S")
weather.df <- weather.df %>% mutate(time, date.only = as.Date(time))
# return weather.df
return(weather.df)
}
# test
data <- weatherData("Olympia", "WA", "2017-05-25")
# server.R
# Libraries
library(dplyr)
library(rgeos)
library(shiny)
library(plotly)
library(httr)
library(stringr)
library(rjson)
library(jsonlite)
library(anytime)
# Scripts
source('scripts/setup.R')
source('scripts/analysis.R')
source('scripts/build.R')
# shinyServer
shinyServer(function(input, output) {
#Plot
output$mainPlot <- renderPlot({thePlot
})
# Text rendering for about and insights
output$about <- renderText({about})
output$insights <- renderText({insights})
})
# Read in libraries
library(shiny)
library(plotly)
library(shinythemes)
# Read in source scripts
source('scripts/setup.R')
#source('scripts/analysis.R')
# Create Shiny UI
shinyUI(fluidPage(theme = shinytheme("superhero"),
# Application title
titlePanel("Twitter and Weather"),
# Sidebar with select inputs for date, time, and city
sidebarLayout(
sidebarPanel(
# Returns Capital City, State
selectInput("city", "Select City", choices = cities),
# Returns YYYY-MM-DD
dateInput("date", "Select Date", max = Sys.Date()),
# Returns "1" "2" and/or "3"
checkboxGroupInput("plots", "Select Plots", choices = plots)
),
# Plot it!
mainPanel(
tabsetPanel(
# Plot panel
tabPanel("Plot", plotlyOutput('mainPlot', height = "600px", width = "800px"))
#,
# Insights panel
#tabPanel("Insights", textOutput('insights')),
# About panel
#tabPanel("About", textOutput('about'))
)
)
)
)
)
runApp()
# Read in scripts
source('scripts/setup.R')
# Temperature Line Graph
thePlot <- plot_ly(my.data,
x = ~time,
y = ~temperature,
colors = "PuRd",
type = 'scatter',
mode = 'lines+markers',
hoverinfo = 'text',
text = ~paste0('Location: ', ~get(input$city),
'</br>', "Time: ", my.data$time.only,
'</br>', "Temperature ", my.data$temperature),
marker = list(colorbar = list(title = input$color)))  %>%
layout(title = "Title Here",
xaxis = x,
yaxis = y
)
plotly_build(p)
runApp()
runApp()
runApp()
runApp()
runApp()
